This is Info file OSis.info, produced by Makeinfo-1.63 from the input
file OSis.texi.

   This file documents OSis, the TOS emulator for Linux/68k.

   This documentation is still under construction and some parts are
missing. Also, since OSis currently develops very quickly, the
documentation will not always be really up-to-date. Be patient!

   Copyright (C) 1996 Roman Hodek

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: OSis.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

OSis
****

   OSis is a TOS emulator for Linux/68k. It consists of the main parts
oTOSis, oVDIis and oAESis, each responsible for emulating the respective
major parts of TOS.

   Currently, oTOSis can run not too complex or badly programmed
`.TOS'/`.TTP' executables. oAESis is developed under the native
TOS/MiNT environment as replacement for MultiTOS' AES and will be
integrated into the OSis project later. oVDIis will come later.

* Menu:

* Overview::                    Summary of what OSis does.
* History::                     Some words about the evolution of OSis.
* General Usage::               How to use OSis in the every-day case.
* Configuration and Invocation::  Command line arguments and
                                  configuration files of OSis
* Technical Details::           How OSis works internally.

* Option Index::
* Concept Index::

 -- The Detailed Node Listing --

Configuration and Command Line Options

* Option Basics::               General syntax of options.
* Configuration File Syntax::   Syntax of OSis' configuration files.
* Command Line::                Now the command line looks like and how
                                arguments are treated.
* Option Setting Precedence::   Which settings come in effect?
* Program Specific Settings::   How to set different values for
                                different TOS programs in config files.
* Options::                     Detailed list of all OSis options.

Available Options

* Debugging and Emulation Type::
* Path Settings::
* Memory Layout::

Technical Details

* TOS System Calls::            How TOS system calls are catched and
                                emulated.
* Hardware Registers::          How access to hardware I/O registers is
                                emulated.
* I/O Redirection::             Relations of I/O redirection under Unix and
                                GEMDOS.


File: OSis.info,  Node: Overview,  Next: History,  Prev: Top,  Up: Top

Overview of OSis
****************

   OSis is a TOS emulator for Linux/68k. It is intended to (once) run
every cleanly written GEM or TOS program under Linux. The OSis project
consists of three main parts: oTOSis, the GEMDOS/MiNT/BIOS/XBIOS
emulation, which provides basic operation system services to TOS
applications. Next oVDIis, that implements VDI drawing functions under
X, and last oAESis as AES/MultiTOS replacement.

   Current state of the art is that oTOSis 0.23 can run many
`.TOS'/`.TTP' (i.e., non-GUI) programs, but is still under heavy and
fast development. oVDIis is still vapour, but a first public version
may be released soon. oAESis is currently developed under the native
TOS/MiNT enviroment and has reached version 0.76. It is already able to
run several GEM applications. But for integration into OSis under
Linux, still several adaptions will be needed.

   The emulator executable under Linux is simply called `tos'. It takes
the TOS program to execute as argument and determines itself whether it
is a console program (`.TOS' or `.TTP') or a GEM application (`.PRG' or
`.APP'). Obviously, GEM programs need X running, while console-oriented
ones do not. The latter can also work in normal Unix pipelines, since
OSis gets the I/O redirections right for this.


File: OSis.info,  Node: History,  Next: General Usage,  Prev: Overview,  Up: Top

History
*******

   The idea of writing a TOS emulator dates back to the oldest times of
Linux/68k on Atari, inspired by the existance of dosemu on Linux/i386.
First thoughts about how it could be implemented were made in the German
MausNet newsgroup `LINUX-68K', mainly by Martin Schaller
(`<Martin_Schaller@r.maus.de>') and Roman Hodek
(`<Roman.Hodek@informatik.uni-erlangen.de>'). It was quickly agreed on
that the `tosemu' (the suggestive preliminary name for the kid) should
require as little kernel support as possible, and thus using signals
for emulation (*note Technical Details::.) is the best way to go.

   Shortly after that discussion, Martin Schaller started coding, and
after a few days (!), he had a first prototype ready. It could already
run simple TOS programs. But then, all of Martin's sources were
shreddered by an accident: He wanted to take a book from the shelf, and
on the way he hit a bottle of coke and poured it over his brand-new 1GB
disk lying around on the desk. A screaming noise indicated the
consequences...  Yes, Martin is a careful man and makes backups every
few days, but the `tosemu' was too new, unfortunately. So all his work
was gone forever. That's life...

   In the time following, there were many more important projects, so
noone of the Linux developers had time again to start again working on
the `tosemu'. Finally, Martin disappeared silently from the Linux scene
and took all his experiences with him. After maybe a year, the next try
was started by Roman Hodek. But he was a perfectionist, and attempted to
write an incredible ingenious configuration mechanism (with structured
and arrayed variables, `yacc' grammar, and other funny features).  So
ingenious that --some days later-- he himself didn't understand it
anymore... Again, there were other important things to do, so the
sources were lying around and didn't even compile.

   Next one was Elias Martenson. He started from scratch and really
managed it to get it run (and to keep the sources :-). After some
version steps (0.17 as far as I can remember), he released his work to
the public.  Also Roman supplied his old sources, for ideas how to make
some low-level things. But that `tosemu' version used some hard-coded
offsets and ran only uder Linux version 0.9. That one was dropped in
favour of 1.2 soon thereafter, and `tosemu' didn't work anymore.  Roman
promised to fix that, but again had more important things to do.
(Hasn't that been the case once before?) Also Elias was busy with his
job and had little time for `tosemu', so the project was sleeping again.

   Finally, in June '96, Elias came up with a new version (0.21). At
that time, Roman had just given up his job as Linux/68k coordinator,
and thus incidentally had some spare time for oTOSis (that's the name
Elias has christened `tosemu' in the meantime). Both of them are
currently developing oTOSis and adding feature after feature.

   Elias also managed to persuade some friends to join the project.
Stefan Berndtsson volunteered for oVDIis, and Christer Gustavsson for
oAESis.


File: OSis.info,  Node: General Usage,  Next: Configuration and Invocation,  Prev: History,  Up: Top

General Usage
*************

   Not yet started...


File: OSis.info,  Node: Configuration and Invocation,  Next: Technical Details,  Prev: General Usage,  Up: Top

Configuration and Command Line Options
**************************************

   OSis implements a unified mechanism for configuration files and
command line options. This makes it easier for you to remember option
names and the like. In general, every setting that can be made in a
config file can also be made on the command line, and vice versa.

   In the following, the term "option" will be used for what you know
either as command line arguments or configuration file variables. Both
things are effectively the same for OSis, and option will be used as the
general term. On the other hand, "argument" always will refer to
something written on the command line, and "variable" to something in a
configuration file.

* Menu:

* Option Basics::               General syntax of options.
* Configuration File Syntax::   Syntax of OSis' configuration files.
* Command Line::                Now the command line looks like and how
                                arguments are treated.
* Option Setting Precedence::   Which settings come in effect?
* Program Specific Settings::   How to set different values for
                                different TOS programs in config files.
* Options::                     Detailed list of all OSis options.


File: OSis.info,  Node: Option Basics,  Next: Configuration File Syntax,  Prev: Configuration and Invocation,  Up: Configuration and Invocation

Option Basics
=============

   Every option has a name, consisting of a sequence of letters and
digits, and a value. Possible values depend on the type of the option.
The type is one of boolean, integer, or string. Many option also have an
associated shortcut letter that may be used to set their value on the
command line (*note Command Line Parsing: Command Line.).

   A string can be any sequence of characters. An integer is written as
you would except it, i.e. as a series of digits, maybe with a leading
`-' for negative numbers, and maybe with `0' or `0x' prefixes for octal
or hexadecimal, resp. To be exact: A valid integer is everything the C
function `atol()' can parse.

   Finally, valid boolean values for TRUE are `yes', `y', `on', `1',
and analogous `no', `n', `off', and `0' for FALSE. All words used for
boolean values are case-insensitive. That means, you could write `YeS',
if you like.


File: OSis.info,  Node: Configuration File Syntax,  Next: Command Line,  Prev: Option Basics,  Up: Configuration and Invocation

Configuration File Syntax
=========================

   OSis queries two configuration files for option settings: A
system-wide file `/etc/tos/conf', and a user-specific file `~/.tos'.
Both files have exactly the same syntax and the same semantics. The
latter is indented for giving users the chance to overwrite system-wide
settings.  *Note Precendence of Option Settings: Option Setting
Precedence, for more information on priorities.

   For the main part, a configuration file consists of variable
settings of the general form
     OPTION-NAME = VALUE
   Lines starting with a `#' (after whitespace) are treated as comments
and are completely ignored, as are any empty lines.

   What is possible for VALUE depends on the option type: boolean,
integer or string. *Note Option Basics::, for information on valid
values for these types.

   Another type of line in a config file is the header of a program
specific section (*note Program Specific Settings::.), with the form:
     PROGRAM-NAME:
   Any number of whitespace is accepted between the PROGRAM-NAME and
the colon, but the `:' must be the last (non-white) character on the
line.

   The exact parsing mechanism is as follows:
  1. Any whitespace characters (spaces, tabs, and newlines) are
     stripped from both the start and end of a line.

  2. If the line is now empty or starts with `#', it is skipped.

  3. If a colon is found at the end of the line, the line is the header
     of a program-specific section.

  4. Otherwise, the line has to be an option setting, and after the
     name, a `=' is expected. Any number of whitespace is accepted
     around the `='. The rest of the line, after `=' plus spaces, is the
     option value.


   Items 1 and 4 taken together also mean that you can't include
whitespace at the start or end of any string variable, since there's no
quoting mechanism. But you can freely write any whitespace inside such
a string, it is included into the value without any changes.


File: OSis.info,  Node: Command Line,  Next: Option Setting Precedence,  Prev: Configuration File Syntax,  Up: Configuration and Invocation

Command Line Parsing
====================

   The command line of OSis has the general structure

     `tos' [OSIS-OPTIONS] TOS-PROGRAM [PROGRAM-ARGS]

   *Every* argument in the OSIS-OPTIONS has to start with a hyphen
(`-'). This allows `tos' to find out which argument is TOS-PROGRAM,
which may not start with a `-'. All arguments following TOS-PROGRAM
belong to PROGRAM-ARGS and are passed along to the TOS program.
Alternatively, you can force the next argument to be TOS-PROGRAM by
writing `--'.

   Following the OSis philosophy that all setting can be done equally in
option files and on the command line, possible options are described
later, together with configuration variables (*note Available Options:
Options.).

   But there are a two arguments with no config variable equivalent:

 - Command Line Option: -h
     Print a help message with usage syntax and brief listing of
     possible options. Example:
          tos -h
               -| Usage: tos [-options] tos-program [tos-options]
               -| Possible options are:
               -|   -h: This help message
               -|   -v: Print version information
               -|   -oname=value: set arbitrary option by long name
               -|   -d: debug
               -|   -r<int>, -oextra_mem=<int>
                        ...

 - Command Line Option: -v
     Print version information of OSis, e.g.:
          tos -v
               -| oTOSis version 0.23
               -| Compiled 07/09/96 15:36:04 by rnhodek on emilio
               -| with gcc version 2.7.2

   Arguments starting with a double hyphen (`--') are long-named
arguments, as usual with GNU programs. Long option names can be used in
the following ways:

     --OPTION-NAME=VALUE
     --BOOLEAN-OPTION
     --noBOOLEAN-OPTION

   With `--' arguments, you can set an arbitrary option by giving its
long name. For rarely used options, the long names may be easier to
remember than the associated shortcut letters. The VALUE is parsed as
usual. *Note Option Basics::, for more information on that parsing.

   For options of type boolean, you can omit the `=' and the VALUE,
which sets the option to TRUE. And you can additionally prefix the
option's name with `no' to set it to FALSE, as shown in the third line.


File: OSis.info,  Node: Option Setting Precedence,  Next: Program Specific Settings,  Prev: Command Line,  Up: Configuration and Invocation

Precedence of Option Settings
=============================

   OSis knows four sources for option values, that are queried in the
order following. That means, the later source has higher priority when
more than one source try to set the same option value, because it is
seen later and overwrites the previous setting.

  1. Every option has a default value that is used only if the option
     isn't set by one of the following.

  2. The global configuration file `/etc/tos.conf' is used for
     system-wide settings, and written by the administrator.

  3. The user configuration file `~/.tos' can be used for user-specific
     option settings.

  4. Finally, command line arguments are for temporarily modifying the
     fixed settings in the configuration files.



File: OSis.info,  Node: Program Specific Settings,  Next: Options,  Prev: Option Setting Precedence,  Up: Configuration and Invocation

Program Specific Option Settings
================================

   OSis provides a mechanism for setting (or overriding) certain option
values only for one TOS program. This is useful if, for instance,
`XY.PRG' needs more memory in its TPA than usual programs. Then you can
override the standard `extra_mem' value just for `XY.PRG'.

   It works as follows: In every configuration file, you can start a
program-sepcific section with a line
     PROGRAM-NAME:
   After that line, all variable definitions apply to that program only.
The section is ended by either the start of another program-specific
section, or by the end of the file. Thus, write program-specific setting
at the end of a config file, after any general settings.

   The PROGRAM-NAME is compared case-insensitively to the filename part
(after the last `/' or `\') of the currently executed TOS program.


File: OSis.info,  Node: Options,  Prev: Program Specific Settings,  Up: Configuration and Invocation

Available Options
=================

   The following sections list all available options of OSis, ordered by
functional groups.

* Menu:

* Debugging and Emulation Type::
* Path Settings::
* Memory Layout::


File: OSis.info,  Node: Debugging and Emulation Type,  Next: Path Settings,  Prev: Options,  Up: Options

Debugging and Emulation Type
----------------------------

 - Option (boolean): debug
     If `debug' is TRUE, OSis prints extensive debugging information
     while running. The messages include all TOS calls done by the
     program, with arguments and return value. Also some messages about
     internal state of OSis are printed.

 - Option (boolean): trace
     If `trace' is TRUE, OSis will enter a trace monitor each time the
     TOS program executes a system call. Type `help' at the monitor's
     prompt to see available commands. You can also toggle this trace
     mode by sending `SIGUSR1' to the OSis process.

 - Option (boolean): MiNT
     If `MiNT' is TRUE, OSis does full emulation of MiNT system calls
     and other specialities of MiNT. Since MiNT is fully compatible to
     standard GEMDOS, there are no obvious reasons to ever turn MiNT
     off. The only case where it could make some sense is if you want
     some program linked with the MiNT library not to run in the MiNT
     domain.

 - Option (boolean): aux_stderr
     If this option is TRUE, GEMDOS handle 2 is not the `AUX:' device,
     but `CON:' (BIOS devices 1 or 2, resp.). Many GNU programs under
     TOS assume they can print error messages on handle 2, and `AUX:'
     is rarely used this way, so this option is on by default. If a
     program should expect handle 2 to be the serial port, set
     `aux_stderr' to FALSE. But note that `aux_stderr' being true does
     not mean you cannot use the `AUX:' device anymore! If a programs
     opens it explicitly by name, it works as usual. The only effect of
     `aux_stderr' is the initial setting of GEMDOS standard handle 2.


File: OSis.info,  Node: Path Settings,  Next: Memory Layout,  Prev: Debugging and Emulation Type,  Up: Options

Path Settings
-------------

 - Option (string): path
     The value of this option is passed as TOS environment variable
     `PATH' to the TOS program. It is also used for searching for the
     executable if no path is given for it on the command line.

 - Option (string): drive
     (where X is any upper-case letter from `A' to `Z', except `U')

     The `driveX' options give the Unix path associated with a GEMDOS
     drive. An access to a file `X:\\path\\file' by the TOS program is
     translated to `DRIVEX-PATH/path/file'. That means, the configured
     path name of a drive is the root of the filesystem on that drive
     for GEMDOS. The value of each `driveX' therefore should be an
     absolute path and should point to a directory, that serves as the
     pseudo-root.

     GEMDOS-drive `U:' is treated specially, and there is *no* option
     `driveU'. Accesses to drive `U:' are handled in a way similar to
     MiNT, i.e. each other drive appears as subdirectory there, and
     there are directories `PIPE', `DEV', ... (Those special
     directories' functions aren't emulated yet.)

     In addition to the MiNT behaviour, `U:' contains every file or
     directory contained in the real Unix root directory. With this
     feature, standard Unix filenames on the command line can be
     handled correctly if the default drive is `U:'.


File: OSis.info,  Node: Memory Layout,  Prev: Path Settings,  Up: Options

Memory Layout
-------------

 - Option (integer): extra_mem
     `extra_mem' defines the extra TPA space to reserve for the TOS
     program.

     The real GEMDOS picks the biggest free memory chunk when starting a
     program, and calls it the "TPA". That means, the size of memory the
     program initially gets is determined by the amount of available
     memory.  But under Unix, there's virtually unlimited memory, so
     it's not clear how much memory to give to the TOS program.

     So OSis calculates the size of the TPA as CODE-SIZE + DATA-SIZE +
     BSS-SIZE + `extra_mem'. The first three numbers are determined by
     the program header and are an minimum the program needs. The rest
     `extra_mem'kByte are usually used for the program's stack and
     maybe extra dynamically allocated storage.  Unused parts of the
     TPA are normally freed after startup with `Mshrink()'. The default
     of 8192kByte should be enough in most cases.

 - Option (integer): mem_free
     `mem_free' determines how many free memory OSis announces when the
     GEMDOS function `Malloc(-1)' is called. Since there's virtually
     unlimited memory under Unix, it's not clear how much memory should
     be reported as being free. As alternative, OSis always pretends
     `mem_free'kByte are free.

     This could be a problem for programs the call `Malloc(-1)'
     repeatedly to allocate all chunks of free memory, e.g. to
     determine the whole size of free memory, not only the biggest
     chunk. Since OSis always answers that there are `mem_free'kByte
     free, those programs will run into an endless loop. Maybe there
     should be a workaround for this in future versions.


File: OSis.info,  Node: Technical Details,  Next: Option Index,  Prev: Configuration and Invocation,  Up: Top

Technical Details
*****************

   This chapter will introduce into some implementation details of
OSis. It is intended for the interested reader and does not attempt to
be a full programmers' documentation.

* Menu:

* TOS System Calls::            How TOS system calls are catched and
                                emulated.
* Hardware Registers::          How access to hardware I/O registers is
                                emulated.
* I/O Redirection::             Relations of I/O redirection under Unix and
                                GEMDOS.


File: OSis.info,  Node: TOS System Calls,  Next: Hardware Registers,  Prev: Technical Details,  Up: Technical Details

Catching TOS System Calls
=========================

   Need to write something here...


File: OSis.info,  Node: Hardware Registers,  Next: I/O Redirection,  Prev: TOS System Calls,  Up: Technical Details

Emulation of Hardware Registers
===============================

   Need to write something here...


File: OSis.info,  Node: I/O Redirection,  Prev: Hardware Registers,  Up: Technical Details

Handling of I/O Redirection
===========================

   Need to write something here...


File: OSis.info,  Node: Option Index,  Next: Concept Index,  Prev: Technical Details,  Up: Top

Option Index
************

* Menu:

* -h:                                   Command Line.
* -v:                                   Command Line.
* aux_stderr:                           Debugging and Emulation Type.
* debug:                                Debugging and Emulation Type.
* drive:                                Path Settings.
* extra_mem:                            Memory Layout.
* mem_free:                             Memory Layout.
* MiNT:                                 Debugging and Emulation Type.
* path:                                 Path Settings.
* trace:                                Debugging and Emulation Type.


File: OSis.info,  Node: Concept Index,  Prev: Option Index,  Up: Top

Concept Index
*************

* Menu:


Tag Table:
Node: Top1055
Node: Overview3041
Node: History4401
Node: General Usage7552
Node: Configuration and Invocation7708
Node: Option Basics9076
Node: Configuration File Syntax10133
Node: Command Line12244
Node: Option Setting Precedence14648
Node: Program Specific Settings15563
Node: Options16576
Node: Debugging and Emulation Type16889
Node: Path Settings18672
Node: Memory Layout20152
Node: Technical Details21927
Node: TOS System Calls22605
Node: Hardware Registers22815
Node: I/O Redirection23035
Node: Option Index23222
Node: Concept Index23965

End Tag Table
